#!/bin/sh
# /etc/initramfs-tools/scripts/init-bottom/setup_containerd_cache
PREREQ=""
prereqs() { echo "$PREREQ"; }
case $1 in prereqs) prereqs; exit 0;; esac

. /scripts/functions

# Configuration
[ -f /etc/tdx-luks.conf ] && . /etc/tdx-luks.conf

CONTAINERD_LABEL="${CONTAINERD_LABEL:-containerd-cache}"
CONTAINERD_LUKS_NAME="containerd_cache"

# Global variables
CONTAINERD_DEVICE=""
CONTAINERD_KEY=""
VM_NAME=""
HOTKEY=""
BOOT_TOKEN=""
SUCCESS_FLAG=0

# Function to securely clear sensitive data
clear_sensitive_data() {
    if [ -n "$CONTAINERD_KEY" ]; then
        CONTAINERD_KEY="$(head -c 1000 /dev/urandom 2>/dev/null | base64 | tr -d '\n' | head -c 1000)"
        CONTAINERD_KEY=""
        unset CONTAINERD_KEY
    fi
    
    if [ -n "$BOOT_TOKEN" ]; then
        BOOT_TOKEN="$(head -c 1000 /dev/urandom 2>/dev/null | base64 | tr -d '\n' | head -c 1000)"
        BOOT_TOKEN=""
        unset BOOT_TOKEN
    fi
    
    rm -f /tmp/containerd_response
    
    # If script exits without success flag, shutdown the VM
    if [ "$SUCCESS_FLAG" -ne 1 ]; then
        log_failure_msg "Containerd cache setup failed - VM will shut down in 10 seconds..."
        echo "CONTAINERD-CACHE-SETUP-FAILED" > /dev/kmsg
        sleep 10
        poweroff -f
    fi
}

trap clear_sensitive_data EXIT INT TERM

log_begin_msg "Starting containerd cache setup"

# Function to load VM name, hotkey, and boot token
load_vm_data() {
    if [ ! -f /run/chutes/vm-name ]; then
        log_failure_msg "VM name not found in /run/chutes/vm-name"
        return 1
    fi
    
    VM_NAME=$(cat /run/chutes/vm-name)
    
    if [ ! -f /run/chutes/hotkey ]; then
        log_failure_msg "Hotkey not found in /run/chutes/hotkey"
        return 1
    fi
    
    HOTKEY=$(cat /run/chutes/hotkey)
    
    if [ ! -f /run/chutes/boot-token ]; then
        log_failure_msg "Boot token not found in /run/chutes/boot-token"
        return 1
    fi
    
    BOOT_TOKEN=$(cat /run/chutes/boot-token)
    
    log_success_msg "Loaded VM name: $VM_NAME, hotkey loaded from config"
    return 0
}

# Function to detect containerd cache device by label
detect_containerd_device() {
    log_begin_msg "Detecting containerd cache device by label: $CONTAINERD_LABEL"
    
    # Wait a bit for devices to settle
    sleep 2
    
    # First, try to find device by filesystem label (works for unencrypted devices on first boot)
    CONTAINERD_DEVICE=$(blkid -l -o device -t LABEL="$CONTAINERD_LABEL" 2>/dev/null)
    
    # If not found, check for LUKS devices with the subsystem label
    # This is more reliable than filesystem labels since LUKS metadata is accessible without opening
    if [ -z "$CONTAINERD_DEVICE" ]; then
        log_begin_msg "Filesystem label not found, checking for LUKS devices"
        
        # Use blkid to find all block devices, then check each for LUKS with our label
        # This is more reliable than globbing /dev paths
        for dev in $(blkid -o device 2>/dev/null); do
            [ -b "$dev" ] || continue
            
            # Check if it's a LUKS device
            if cryptsetup isLuks "$dev" 2>/dev/null; then
                # Extract label from LUKS header
                luks_label=$(cryptsetup luksDump "$dev" 2>/dev/null | grep -E "^Label:" | sed 's/^Label:[[:space:]]*//')
                
                log_begin_msg "Checking device $dev: label='$luks_label'"
                
                if [ "$luks_label" = "$CONTAINERD_LABEL" ]; then
                    CONTAINERD_DEVICE="$dev"
                    log_success_msg "Found LUKS device with label: $CONTAINERD_DEVICE"
                    break
                fi
            fi
        done
    fi
    
    if [ -z "$CONTAINERD_DEVICE" ]; then
        log_failure_msg "No device found with label '$CONTAINERD_LABEL'"
        log_failure_msg "Ensure the cache volume was created with create-cache.sh script"
        return 1
    fi
    
    if [ ! -b "$CONTAINERD_DEVICE" ]; then
        log_failure_msg "Device $CONTAINERD_DEVICE is not a block device"
        return 1
    fi
    
    log_success_msg "Found containerd device: $CONTAINERD_DEVICE"
    return 0
}

# Function to retrieve existing containerd key (GET) for encrypted devices
get_containerd_key() {
    local response_file="/tmp/containerd_response"
    
    # Validate required configuration
    if [ -z "$TDX_LUKS_ENDPOINT" ]; then
        log_failure_msg "TDX_LUKS_ENDPOINT not configured in /etc/tdx-luks.conf"
        return 1
    fi
    
    local luks_endpoint="$TDX_LUKS_ENDPOINT"
    local timeout="${TDX_TIMEOUT:-30}"
    local ca_cert="/etc/ssl/certs/ca-certificates.crt"
    
    # Substitute vm_name in endpoint URL
    local endpoint_url="$(echo "$luks_endpoint" | sed "s/vm_name/$VM_NAME/g")"
    # Add query parameters for GET
    endpoint_url="${endpoint_url}?hotkey=$(printf '%s' "$HOTKEY" | sed 's/ /%20/g')"
    
    log_begin_msg "Retrieving existing containerd key from $endpoint_url"
    
    # GET request with boot token in X-Boot-Token header
    http_code=$(curl -s -w "%{http_code}" \
        -X GET \
        -H "X-Boot-Token: $BOOT_TOKEN" \
        -H "User-Agent: TDX-LUKS-Containerd/1.0" \
        --max-time "$timeout" \
        --retry 0 \
        --cacert "$ca_cert" \
        -o "$response_file" \
        "$endpoint_url")
    
    if [ "$http_code" = "200" ]; then
        CONTAINERD_KEY=$(grep -o '"passphrase":"[^"]*"' "$response_file" | cut -d'"' -f4)
        
        if [ -n "$CONTAINERD_KEY" ]; then
            rm -f "$response_file"
            log_success_msg "Containerd key retrieved"
            return 0
        fi
    fi
    
    rm -f "$response_file"
    log_failure_msg "Failed to get containerd key (HTTP $http_code)"
    return 1
}

# Function to store new containerd key (PUT) for unencrypted devices (first boot)
put_containerd_key() {
    local response_file="/tmp/containerd_response"
    
    # Validate required configuration
    if [ -z "$TDX_LUKS_ENDPOINT" ]; then
        log_failure_msg "TDX_LUKS_ENDPOINT not configured in /etc/tdx-luks.conf"
        return 1
    fi
    
    local luks_endpoint="$TDX_LUKS_ENDPOINT"
    local timeout="${TDX_TIMEOUT:-30}"
    local ca_cert="/etc/ssl/certs/ca-certificates.crt"
    
    # Substitute vm_name in endpoint URL
    local endpoint_url="$(echo "$luks_endpoint" | sed "s/vm_name/$VM_NAME/g")"
    # Add query parameters for PUT
    endpoint_url="${endpoint_url}?hotkey=$(printf '%s' "$HOTKEY" | sed 's/ /%20/g')"
    
    log_begin_msg "Requesting new containerd key from $endpoint_url"
    
    # PUT request - validator generates and returns new key, boot token in header
    http_code=$(curl -s -w "%{http_code}" \
        -X PUT \
        -H "X-Boot-Token: $BOOT_TOKEN" \
        -H "User-Agent: TDX-LUKS-Containerd/1.0" \
        --max-time "$timeout" \
        --retry 0 \
        --cacert "$ca_cert" \
        -o "$response_file" \
        "$endpoint_url")
    
    if [ "$http_code" = "200" ] || [ "$http_code" = "201" ]; then
        CONTAINERD_KEY=$(grep -o '"passphrase":"[^"]*"' "$response_file" | cut -d'"' -f4)
        
        if [ -n "$CONTAINERD_KEY" ]; then
            rm -f "$response_file"
            log_success_msg "Received new containerd key from validator"
            return 0
        fi
    fi
    
    rm -f "$response_file"
    log_failure_msg "Failed to get new containerd key (HTTP $http_code)"
    return 1
}

# Function to setup containerd cache device
setup_containerd_cache() {
    local is_encrypted=false
    
    # Check if device is LUKS encrypted
    if cryptsetup isLuks "$CONTAINERD_DEVICE" 2>/dev/null; then
        is_encrypted=true
        log_begin_msg "Containerd device is LUKS encrypted"
    else
        log_begin_msg "Containerd device is NOT encrypted (first boot)"
    fi
    
    # Validate boot token exists
    if [ -z "$BOOT_TOKEN" ]; then
        log_failure_msg "No boot token available"
        return 1
    fi
    
    # Now encrypt or unlock the device
    if [ "$is_encrypted" = "true" ]; then
        # GET existing key for encrypted device
        if ! get_containerd_key; then
            log_failure_msg "Failed to retrieve existing containerd key"
            return 1
        fi
        
        # Unlock existing encrypted device
        log_begin_msg "Unlocking containerd cache"
        
        if ! printf '%s' "$CONTAINERD_KEY" | cryptsetup luksOpen "$CONTAINERD_DEVICE" "$CONTAINERD_LUKS_NAME" --key-file=-; then
            log_failure_msg "Failed to unlock containerd cache"
            return 1
        fi
        
        log_success_msg "Containerd cache unlocked"
    else
        # First boot: Request new key from validator, wipe, restore label, encrypt
        log_begin_msg "Encrypting containerd cache (first boot)"
        
        # PUT request to validator to generate/return new key (create or overwrite if old cache was recreated)
        if ! put_containerd_key; then
            log_failure_msg "Failed to get new containerd key from validator"
            return 1
        fi
        
        if [ -z "$CONTAINERD_KEY" ]; then
            log_failure_msg "Validator returned empty containerd key"
            return 1
        fi
        
        # SECURITY: Wipe device
        log_begin_msg "Wiping device..."
        wipefs -a "$CONTAINERD_DEVICE" 2>/dev/null || true
        dd if=/dev/zero of="$CONTAINERD_DEVICE" bs=1M count=10 2>/dev/null || true
        
        # SECURITY: Wipe any old LUKS header
        log_begin_msg "Wiping old LUKS header if present..."
        cryptsetup erase "$CONTAINERD_DEVICE" 2>/dev/null || true
        
        # Create LUKS container with subsystem label for detection on subsequent boots
        log_begin_msg "Creating LUKS container with label..."
        if ! printf '%s' "$CONTAINERD_KEY" | cryptsetup luksFormat --type luks2 --label "$CONTAINERD_LABEL" "$CONTAINERD_DEVICE" --key-file=-; then
            log_failure_msg "Failed to create LUKS container"
            return 1
        fi
        
        # Open encrypted device
        if ! printf '%s' "$CONTAINERD_KEY" | cryptsetup luksOpen "$CONTAINERD_DEVICE" "$CONTAINERD_LUKS_NAME" --key-file=-; then
            log_failure_msg "Failed to open LUKS container"
            return 1
        fi
        
        # Format with ext4 and label
        log_begin_msg "Formatting containerd cache..."
        if ! mkfs.ext4 -L "$CONTAINERD_LABEL" "/dev/mapper/$CONTAINERD_LUKS_NAME"; then
            log_failure_msg "Failed to format containerd cache"
            return 1
        fi
        
        log_success_msg "Containerd cache encrypted and formatted"
    fi
    
    return 0
}

# Function to handle failure and shutdown
handle_failure() {
    local reason="$1"
    
    log_failure_msg "Containerd cache setup failed: $reason"
    log_failure_msg "VM will shut down in 10 seconds..."
    
    # Log to kernel ring buffer for debugging
    echo "CONTAINERD-CACHE-SETUP-FAILED: $reason" > /dev/kmsg
    
    # Clear sensitive data before shutdown
    clear_sensitive_data
    
    # Give time to see the message
    sleep 10
    
    # Power off the system
    poweroff -f
}

# Main execution
main() {
    # Load VM ID and boot token from /run
    if ! load_vm_data; then
        handle_failure "Cannot proceed without VM ID"
        return 1
    fi
    
    # Detect containerd device
    if ! detect_containerd_device; then
        handle_failure "No containerd device found"
        return 1
    fi
    
    # Setup (encrypt or unlock) containerd cache
    if ! setup_containerd_cache; then
        handle_failure "Failed to setup containerd cache"
        return 1
    fi
    
    # Mark as successful before cleanup
    SUCCESS_FLAG=1
    
    # Clear all sensitive data
    clear_sensitive_data
    
    log_success_msg "Containerd cache setup completed successfully"
    return 0
}

# Run main
main
exit_code=$?

log_end_msg $exit_code
exit $exit_code
