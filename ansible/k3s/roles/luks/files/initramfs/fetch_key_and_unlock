#!/bin/sh
# /etc/initramfs-tools/scripts/init-premount/fetch_key_and_unlock
PREREQ="load-tdx network"
prereqs() { echo "$PREREQ"; }
case $1 in prereqs) prereqs; exit 0;; esac

. /scripts/functions

# Configuration
[ -f /etc/tdx-luks.conf ] && . /etc/tdx-luks.conf

# Validate required configuration
if [ -z "$TDX_API_ENDPOINT" ] || [ -z "$TDX_NONCE_ENDPOINT" ]; then
    echo "ERROR: Missing required TDX configuration. Check /etc/tdx-luks.conf" >&2
    exit 1
fi

API_ENDPOINT="$TDX_API_ENDPOINT"
NONCE_ENDPOINT="$TDX_NONCE_ENDPOINT"
DEVICE_PATH="${LUKS_DEVICE:-/dev/vda1}"
LUKS_NAME="${LUKS_NAME:-encrypted_root}"
TIMEOUT="${TDX_TIMEOUT:-30}"
RETRY_COUNT="${TDX_RETRY_COUNT:-3}"
CLIENT_CERT="/tmp/client_cert.pem"
CLIENT_KEY="/tmp/client_key.pem"
API_CA_CERT="/etc/ssl/certs/ca-certificates.crt"

# Global variables
LUKS_KEY=""
BOOT_TOKEN=""
VM_NAME=""
HOTKEY=""
SUCCESS_FLAG=0

# Function to securely clear the LUKS key and temporary files
clear_luks_key() {
    if [ -n "$LUKS_KEY" ]; then
        # Overwrite with random data multiple times for defense in depth
        LUKS_KEY="$(head -c 1000 /dev/zero | tr '\0' 'x')"
        LUKS_KEY="$(head -c 1000 /dev/urandom 2>/dev/null | base64 | tr -d '\n' | head -c 1000)"
        LUKS_KEY=""
        unset LUKS_KEY
    fi
    
    if [ -n "$BOOT_TOKEN" ]; then
        BOOT_TOKEN="$(head -c 1000 /dev/urandom 2>/dev/null | base64 | tr -d '\n' | head -c 1000)"
        BOOT_TOKEN=""
        unset BOOT_TOKEN
    fi
    
    # Clear any temporary files that might contain sensitive data
    rm -f "$CLIENT_CERT" "$CLIENT_KEY" /tmp/api_response /tmp/nonce_response
    
    # If script exits without success flag, shutdown the VM
    if [ "$SUCCESS_FLAG" -ne 1 ]; then
        log_failure_msg "TDX unlock failed - VM will shut down in 5 seconds..."
        echo "TDX-LUKS-UNLOCK-FAILED" > /dev/kmsg
        sleep 5
        poweroff -f
    fi
}

# Set up trap to ensure cleanup happens on ANY exit
trap clear_luks_key EXIT INT TERM

log_begin_msg "Starting TDX-based disk unlock"
log_begin_msg "Attestation endpoints: nonce=${NONCE_ENDPOINT}, attest=${API_ENDPOINT}"

# Function to generate self-signed client certificate
generate_client_cert() {
    log_begin_msg "Generating self-signed client certificate"
    
    # Set up environment for OpenSSL in initramfs
    export RANDFILE=/tmp/.rnd
    export OPENSSL_CONF=/dev/null
    
    mkdir -p /tmp
    
    # Use openssl to create a self-signed cert (in TDX trust domain)
    if ! openssl req -x509 -newkey rsa:2048 -nodes -sha256 \
        -keyout "$CLIENT_KEY" -out "$CLIENT_CERT" -days 1 \
        -subj "/CN=tdx-vm-$(date +%s)" -batch 2>/dev/null; then
        log_failure_msg "Failed to generate client certificate"
        return 1
    fi
    
    # Verify cert was created
    if [ ! -f "$CLIENT_CERT" ] || [ ! -f "$CLIENT_KEY" ]; then
        log_failure_msg "Certificate files not created"
        return 1
    fi
    
    # Compute SHA-256 hash of cert's public key for REPORTDATA
    CERT_HASH=$(openssl x509 -in "$CLIENT_CERT" -pubkey -noout 2>/dev/null | \
                openssl pkey -pubin -outform der 2>/dev/null | \
                sha256sum | cut -d' ' -f1)
    if [ -z "$CERT_HASH" ]; then
        log_failure_msg "Failed to compute cert hash"
        return 1
    fi
    
    log_success_msg "Client certificate generated"
    return 0
}

# Function to mount config volume
mount_config_volume() {
    local cfg_mount="/run/tdx-config"
    
    log_begin_msg "Mounting config volume"
    
    mkdir -p "$cfg_mount"
    
    # Load virtio drivers (for vdb/vdc attachment)
    modprobe virtio_blk 2>/dev/null
    modprobe virtio_pci 2>/dev/null
    sleep 1
    
    # Mount ext4 config volume labeled "tdx-config"
    for device in /dev/disk/by-label/tdx-config; do
        if [ -b "$device" ]; then
            if mount -t ext4 -o ro "$device" "$cfg_mount" 2>/dev/null; then
                log_success_msg "Config volume mounted at $cfg_mount"
                return 0
            fi
        fi
    done
    
    log_failure_msg "Failed to mount config volume"
    return 1
}

# Function to unmount config volume
unmount_config_volume() {
    local cfg_mount="/run/tdx-config"
    
    if grep -q "$cfg_mount" /proc/mounts 2>/dev/null; then
        umount "$cfg_mount" 2>/dev/null || true
        log_success_msg "Config volume unmounted"
    fi
}

# Function to setup network from cloud-init config (assumes volume is already mounted)
setup_network() {
    local cfg_mount="/run/tdx-config"
    local netconfig="$cfg_mount/network-config.yaml"

    log_begin_msg "Setting up network from config"

    if [ ! -f "$netconfig" ]; then
        log_failure_msg "network-config.yaml not found"
        return 1
    fi

    # Find the first en* interface (auto-detect instead of parsing from config)
    iface=$(ls /sys/class/net/ | grep '^en' | head -n1)
    
    # Parse network settings from netplan YAML
    ip_addr=$(awk '/addresses:/{getline; gsub(/^[ -]+/,""); print; exit}' "$netconfig")
    gateway=$(awk '/via:/{gsub(/^[ ]+via:[ ]+/,""); print; exit}' "$netconfig")
    nameserver=$(awk '/nameservers:/,/addresses:/{if(/^[ ]+-/){gsub(/^[ -]+/,""); print; exit}}' "$netconfig")

    if [ -z "$iface" ] || [ -z "$ip_addr" ] || [ -z "$gateway" ]; then
        log_failure_msg "Failed to detect interface or parse network-config.yaml"
        return 1
    fi

    # Bring up interface
    modprobe virtio_net 2>/dev/null
    sleep 1

    if [ ! -e "/sys/class/net/$iface" ]; then
        log_failure_msg "Interface $iface not found"
        return 1
    fi

    # Configure network
    log_begin_msg "Configuring $iface with $ip_addr"

    ip link set dev "$iface" up
    sleep 1
    
    ip addr add "$ip_addr" dev "$iface"
    ip route add default via "$gateway"

    mkdir -p /etc
    echo "nameserver ${nameserver:-8.8.8.8}" > /etc/resolv.conf

    # Verify
    if ! ip addr show "$iface" | grep -q "inet "; then
        log_failure_msg "Failed to configure IP"
        return 1
    fi

    if ! ip route show | grep -q "default"; then
        log_failure_msg "Failed to configure default route"
        return 1
    fi

    log_success_msg "Network setup complete"
    return 0
}

# Function to read VM name from config volume (assumes volume is already mounted)
read_vm_name() {
    local cfg_mount="/run/tdx-config"
    local hostname_file="$cfg_mount/hostname"
    
    log_begin_msg "Reading VM name from config"
    
    # Read hostname file (VM name is same as hostname)
    if [ ! -f "$hostname_file" ]; then
        log_failure_msg "VM name file not found: $hostname_file"
        return 1
    fi
    
    VM_NAME=$(cat "$hostname_file" 2>/dev/null | tr -d '\n\r\t ' | grep -o '^[[:alnum:]_-]*')
    if [ -n "$VM_NAME" ]; then
        log_success_msg "Found VM name: $VM_NAME"
        return 0
    else
        log_failure_msg "VM name is empty or invalid in $hostname_file"
        cat "$hostname_file" 2>/dev/null | od -c
        return 1
    fi
}

# Function to read hotkey from config volume (assumes volume is already mounted)
read_hotkey() {
    local cfg_mount="/run/tdx-config"
    local hotkey_file="$cfg_mount/miner-ss58"
    
    log_begin_msg "Reading miner hotkey from config"
    
    # Read miner SS58 (hotkey)
    if [ ! -f "$hotkey_file" ]; then
        log_failure_msg "Miner hotkey file not found: $hotkey_file"
        return 1
    fi
    
    HOTKEY=$(cat "$hotkey_file" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)
    if [ -n "$HOTKEY" ]; then
        log_success_msg "Found miner hotkey from config"
        return 0
    else
        log_failure_msg "Miner hotkey is empty or invalid in $hotkey_file"
        cat "$hotkey_file" 2>/dev/null | od -c
        return 1
    fi
}

# Function to fetch nonce from API
fetch_nonce() {
    local response_file="/tmp/nonce_response"
    
    log_begin_msg "Fetching nonce from $NONCE_ENDPOINT"
    
    # Make API request with mTLS
    http_code=$(curl -s -w "%{http_code}" \
        -X GET \
        --max-time $TIMEOUT \
        --retry 0 \
        --cacert "$API_CA_CERT" \
        --cert "$CLIENT_CERT" \
        --key "$CLIENT_KEY" \
        -o "$response_file" \
        "$NONCE_ENDPOINT")
    
    # Check HTTP response code
    case "$http_code" in
        200)
            NONCE=$(grep -o '"nonce":"[^"]*"' "$response_file" | cut -d'"' -f4)
            if [ -n "$NONCE" ]; then
                rm -f "$response_file"
                log_success_msg "Nonce retrieved successfully"
                return 0
            else
                log_failure_msg "API response missing nonce field"
            fi
            ;;
        401|403)
            log_failure_msg "Authentication failed (HTTP $http_code)"
            ;;
        404)
            log_failure_msg "Nonce endpoint not found (HTTP $http_code)"
            ;;
        429)
            log_failure_msg "Rate limited (HTTP $http_code)"
            ;;
        5*)
            log_failure_msg "Server error (HTTP $http_code)"
            ;;
        000)
            log_failure_msg "Connection failed"
            ;;
        *)
            log_failure_msg "Unexpected HTTP response: $http_code"
            ;;
    esac
    
    rm -f "$response_file"
    return 1
}

# Function to generate quote with nonce and cert hash
generate_quote() {
    local quote_file="/tmp/tdx_quote.bin"
    
    log_begin_msg "Generating TDX quote with nonce and cert hash"
    
    # Compute combined hash for REPORTDATA (nonce + cert pubkey)
    REPORTDATA=$(echo -n "${NONCE}${CERT_HASH}" | cut -c1-128)
    
    # Generate quote with REPORTDATA
    if ! /usr/bin/tdx-quote-generator --report-data "$REPORTDATA" --hex -o "$quote_file" 2>/dev/null; then
        log_failure_msg "Failed to generate TDX quote"
        return 1
    fi
    
    if [ ! -f "$quote_file" ]; then
        log_failure_msg "Quote file not created"
        return 1
    fi
    
    # Base64 encode the quote for HTTP transmission
    QUOTE_B64=$(base64 -w 0 < "$quote_file")
    
    rm -f "$quote_file"
    log_success_msg "TDX quote generated"
    return 0
}

# Function to fetch LUKS key from API with fresh nonce for each attempt
fetch_luks_key() {
    local attempt=1
    local response_file="/tmp/api_response"
    
    while [ $attempt -le $RETRY_COUNT ]; do
        log_begin_msg "Fetching LUKS key (attempt $attempt/$RETRY_COUNT)"
        
        # Fetch fresh nonce for this attempt
        if ! fetch_nonce; then
            log_failure_msg "Failed to fetch nonce for attempt $attempt"
            attempt=$((attempt + 1))
            if [ $attempt -le $RETRY_COUNT ]; then
                sleep 2
            fi
            continue
        fi
        
        # Generate quote with the fresh nonce
        if ! generate_quote; then
            log_failure_msg "Failed to generate quote for attempt $attempt"
            attempt=$((attempt + 1))
            if [ $attempt -le $RETRY_COUNT ]; then
                sleep 2
            fi
            continue
        fi
        
        # Make API request with vm_name and miner_hotkey, use mTLS for API request
        log_begin_msg "Sending attestation for VM '$VM_NAME' with miner_hotkey"
        http_code=$(curl -s -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: TDX-LUKS-Client/1.0" \
            -H "X-Chutes-Nonce: $NONCE" \
            --max-time $TIMEOUT \
            --retry 0 \
            --cacert "$API_CA_CERT" \
            --cert "$CLIENT_CERT" \
            --key "$CLIENT_KEY" \
            -d "{\"quote\":\"$QUOTE_B64\",\"vm_name\":\"$VM_NAME\",\"miner_hotkey\":\"$HOTKEY\"}" \
            -o "$response_file" \
            "$API_ENDPOINT")
        
        case "$http_code" in
            200)
                LUKS_KEY=$(grep -o '"key":"[^"]*"' "$response_file" | cut -d'"' -f4)
                BOOT_TOKEN=$(grep -o '"boot_token":"[^"]*"' "$response_file" | cut -d'"' -f4)
                if [ -n "$LUKS_KEY" ]; then
                    rm -f "$response_file"
                    log_success_msg "LUKS key and boot token retrieved successfully"
                    return 0
                else
                    log_failure_msg "API response missing key field"
                fi
                ;;
            401|403)
                log_failure_msg "Authentication failed (HTTP $http_code)"
                # Don't break - might be a transient issue, try with fresh nonce
                ;;
            404)
                log_failure_msg "API endpoint not found (HTTP $http_code)"
                break
                ;;
            429)
                log_begin_msg "Rate limited, waiting before retry..."
                sleep $((attempt * 2))
                ;;
            5*)
                log_failure_msg "Server error (HTTP $http_code), retrying..."
                ;;
            000)
                log_failure_msg "Connection failed, retrying..."
                ;;
            *)
                log_failure_msg "Unexpected HTTP response: $http_code"
                ;;
        esac
        
        attempt=$((attempt + 1))
        if [ $attempt -le $RETRY_COUNT ]; then
            sleep 2
        fi
    done
    
    rm -f "$response_file"
    return 1
}

# Function to unlock LUKS device
unlock_device() {
    log_begin_msg "Unlocking LUKS device $DEVICE_PATH"
    
    # Use global LUKS_KEY variable
    if printf '%s' "$LUKS_KEY" | cryptsetup luksOpen "$DEVICE_PATH" "$LUKS_NAME" --key-file=-; then
        log_success_msg "LUKS device unlocked successfully"
        return 0
    else
        log_failure_msg "Failed to unlock LUKS device"
        return 1
    fi
}



# Function to handle failure and shutdown
handle_failure() {
    local reason="$1"
    
    log_failure_msg "TDX unlock failed: $reason"
    log_failure_msg "VM will shut down in 10 seconds..."
    
    # Log to kernel ring buffer for debugging
    echo "TDX-LUKS-UNLOCK-FAILED: $reason" > /dev/kmsg
    
    # Clear sensitive data before shutdown
    clear_luks_key
    
    # Give time to see the message
    sleep 10
    
    # Power off the system
    poweroff -f
}

# Main execution
main() {
    # Check if we're in a TDX environment
    if [ ! -c "/dev/tdx_guest" ]; then
        handle_failure "TDX device not found - not running in TDX environment"
        return 1
    fi
    
    # Generate self-signed client cert
    if ! generate_client_cert; then
        handle_failure "Client certificate generation failed"
        return 1
    fi
    
    # Mount config volume once for all config reads
    if ! mount_config_volume; then
        handle_failure "Failed to mount config volume"
        return 1
    fi
    
    # Setup network (reads from mounted config volume)
    if ! setup_network; then
        unmount_config_volume
        handle_failure "Network setup failed"
        return 1
    fi
    
    # Read VM name from config volume
    if ! read_vm_name; then
        unmount_config_volume
        handle_failure "Failed to read VM name from config volume"
        return 1
    fi
    
    # Read hotkey from config volume
    if ! read_hotkey; then
        unmount_config_volume
        handle_failure "Failed to read miner hotkey from config volume"
        return 1
    fi
    
    # Unmount config volume now that we have all the data
    unmount_config_volume
    
    # Fetch LUKS key from API (nonce and quote generated per attempt)
    if ! fetch_luks_key; then
        handle_failure "Failed to retrieve LUKS key from API after $RETRY_COUNT attempts"
        return 1
    fi
    
    # Check that we actually got a key
    if [ -z "$LUKS_KEY" ]; then
        handle_failure "LUKS key is empty after fetch"
        return 1
    fi
    
    # Unlock the device
    if unlock_device; then
        # Save vm_name, hotkey, and boot token to /run for containerd cache setup
        mkdir -p /run/chutes
        echo "$VM_NAME" > /run/chutes/vm-name
        echo "$HOTKEY" > /run/chutes/hotkey
        if [ -n "$BOOT_TOKEN" ]; then
            echo "$BOOT_TOKEN" > /run/chutes/boot-token
        fi
        
        # Mark as successful before cleanup
        SUCCESS_FLAG=1
        
        # Clear key from memory immediately after successful unlock
        clear_luks_key
        log_success_msg "TDX-based unlock completed successfully"
        return 0
    else
        handle_failure "Device unlock failed with retrieved key"
        return 1
    fi
}

# Run main function
main
exit_code=$?

log_end_msg $exit_code
exit $exit_code
