---
- name: Check if LUKS container is open
  ansible.builtin.stat:
    path: "/dev/mapper/{{ encrypted_root_name }}"
  register: luks_stat

- name: Close LUKS container if open
  community.crypto.luks_device:
    name: "{{ encrypted_root_name }}"
    state: closed
  when: luks_stat.stat.exists
  ignore_errors: true

- name: Check if nbd device is connected
  ansible.builtin.command: qemu-nbd --check {{ nbd_device }}
  register: nbd_check_result
  failed_when: false
  changed_when: false

- name: Disconnect nbd device if connected
  ansible.builtin.command: qemu-nbd --disconnect {{ nbd_device }}
  when: nbd_check_result.rc == 0
  register: nbd_disconnect_result
  changed_when: nbd_disconnect_result.rc == 0
  ignore_errors: true

- name: Unmount all possible partitions if mounted
  ansible.builtin.mount:
    path: "{{ item }}"
    state: unmounted
  ignore_errors: true
  loop:
    - "{{ newroot_mount }}/sys/firmware/efi/efivars"
    - "{{ newroot_mount }}/proc"
    - "{{ newroot_mount }}/sys"
    - "{{ newroot_mount }}/dev"
    - "{{ newroot_mount }}/run"
    - "{{ newroot_mount }}/boot/efi"
    - "{{ newroot_mount }}/boot"
    - "{{ newroot_mount }}"
    - "{{ root_mount }}/boot/efi"
    - "{{ root_mount }}/boot"
    - "{{ root_mount }}"

- name: Clean up temporary directories if leftover
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  ignore_errors: true
  loop:
    - "{{ root_mount }}"
    - "{{ newroot_mount }}"
    - "{{ backup_dir }}"

- name: Load nbd kernel module
  ansible.builtin.command: modprobe nbd max_part=8
  args:
    creates: /dev/nbd0
  register: modprobe_result
  changed_when: modprobe_result.rc == 0

- name: Connect qcow2 image to nbd device
  ansible.builtin.command: qemu-nbd --connect={{ nbd_device }} {{ final_img_path }}
  args:
    creates: "{{ nbd_device }}p1"
  register: qemu_nbd_result
  changed_when: qemu_nbd_result.rc == 0

- name: Run partprobe to detect partitions
  ansible.builtin.command: partprobe {{ nbd_device }}
  changed_when: false

- name: Check if backup already exists
  ansible.builtin.stat:
    path: "{{ backup_dir }}/etc"
  register: backup_stat

- name: Create mount points
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ root_mount }}"
    - "{{ backup_dir }}"
    - "{{ newroot_mount }}"

- name: Detect partition layout dynamically
  ansible.builtin.shell: |
    set -e
    
    efi=""
    boot=""
    root=""
    
    # Iterate through all partitions
    for part in {{ nbd_device }}p*; do
      fstype=$(blkid -o value -s TYPE "$part" 2>/dev/null || echo "")
      size=$(blockdev --getsize64 "$part" 2>/dev/null || echo "0")
      size_mb=$((size / 1024 / 1024))
      
      case "$fstype" in
        vfat)
          # EFI partition
          efi="$part"
          ;;
        ext4)
          # Distinguish boot vs root by size
          if [ $size_mb -lt 2048 ]; then
            # Small ext4 (< 2GB) is /boot
            boot="$part"
          else
            # Large ext4 is root
            root="$part"
          fi
          ;;
      esac
    done
    
    # Validation
    if [ -z "$efi" ]; then
      echo "ERROR: Could not detect EFI partition" >&2
      exit 1
    fi
    if [ -z "$root" ]; then
      echo "ERROR: Could not detect root partition" >&2
      exit 1
    fi
    if [ -z "$boot" ]; then
      echo "ERROR: Could not detect boot partition" >&2
      exit 1
    fi
    
    echo "efi=$efi"
    echo "boot=$boot"
    echo "root=$root"
  args:
    executable: /bin/bash
  register: partition_detection
  changed_when: false
  failed_when: partition_detection.rc != 0

- name: Parse detected partitions
  ansible.builtin.set_fact:
    efi_partition: "{{ partition_detection.stdout | regex_search('efi=([^\\s]+)', '\\1') | first }}"
    boot_partition: "{{ partition_detection.stdout | regex_search('boot=([^\\s]+)', '\\1') | first }}"
    root_partition: "{{ partition_detection.stdout | regex_search('root=([^\\s]+)', '\\1') | first }}"

- name: Display detected partition layout
  ansible.builtin.debug:
    msg:
      - "Detected partition layout:"
      - "  EFI:  {{ efi_partition }}"
      - "  Boot: {{ boot_partition }}"
      - "  Root: {{ root_partition }}"

- name: Mount root partition
  ansible.builtin.mount:
    path: "{{ root_mount }}"
    src: "{{ root_partition }}"
    fstype: ext4
    state: ephemeral  # Mounts without modifying fstab
  when: not backup_stat.stat.exists

- name: Mount boot partition
  ansible.builtin.mount:
    path: "{{ root_mount }}/boot"
    src: "{{ boot_partition }}"
    fstype: ext4
    state: ephemeral
  when: not backup_stat.stat.exists

- name: Mount EFI partition
  ansible.builtin.mount:
    path: "{{ root_mount }}/boot/efi"
    src: "{{ efi_partition }}"
    fstype: vfat
    state: ephemeral
  when: not backup_stat.stat.exists

- name: Backup root filesystem
  ansible.builtin.command: rsync -aAXv {{ root_mount }}/ {{ backup_dir }}/
  args:
    creates: "{{ backup_dir }}/etc"
  register: rsync_backup_result
  changed_when: rsync_backup_result.rc == 0
  when: not backup_stat.stat.exists

- name: Unmount partitions
  ansible.builtin.mount:
    path: "{{ item }}"
    state: unmounted
  ignore_errors: true
  loop:
    - "{{ root_mount }}/boot/efi"
    - "{{ root_mount }}/boot"
    - "{{ root_mount }}"
  when: not backup_stat.stat.exists

- name: Create LUKS keyfile
  ansible.builtin.copy:
    content: "{{ luks_passphrase | mandatory }}"
    dest: /tmp/luks_keyfile
    mode: '0600'
    owner: root
    group: root

- name: Wipe existing superblock
  ansible.builtin.command: wipefs -a {{ root_partition }}
  register: wipefs_result
  changed_when: wipefs_result.rc == 0
  failed_when: wipefs_result.rc != 0

- name: Create LUKS container
  community.crypto.luks_device:
    device: "{{ root_partition }}"
    state: present
    passphrase: "{{ luks_passphrase }}"
  no_log: true

- name: Open LUKS container
  community.crypto.luks_device:
    device: "{{ root_partition }}"
    state: opened
    name: "{{ encrypted_root_name }}"
    passphrase: "{{ luks_passphrase }}"
  no_log: true

- name: Create ext4 filesystem on LUKS partition
  ansible.builtin.filesystem:
    dev: /dev/mapper/{{ encrypted_root_name }}
    fstype: ext4

- name: Mount encrypted root
  ansible.builtin.mount:
    path: "{{ newroot_mount }}"
    src: "/dev/mapper/{{ encrypted_root_name }}"
    fstype: ext4
    state: ephemeral

- name: Restore data to encrypted root
  ansible.builtin.command: rsync -aAXv {{ backup_dir }}/ {{ newroot_mount }}/
  args:
    creates: "{{ newroot_mount }}/etc"
  register: rsync_restore_result
  changed_when: rsync_restore_result.rc == 0
      
- name: Mount boot partition to new root
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/boot"
    src: "{{ boot_partition }}"
    fstype: ext4
    state: ephemeral

- name: Mount EFI partition to new root
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/boot/efi"
    src: "{{ efi_partition }}"
    fstype: vfat
    state: ephemeral

- name: Bind mount system directories
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/{{ item }}"
    src: "/{{ item }}"
    fstype: none
    opts: bind
    state: ephemeral
  loop:
    - proc
    - sys
    - dev
    - run

# Install TDX quote generator and dependencies
- name: Install build dependencies in chroot
  ansible.builtin.shell: |
    chroot {{ newroot_mount }} /bin/bash -c "
      apt-get update &&
      apt-get install -y build-essential curl dhcpcd-base cryptsetup e2fsprogs ca-certificates openssl
    "
  register: chroot_deps_result
  changed_when: chroot_deps_result.rc == 0

- name: Get UUID of LUKS partition
  ansible.builtin.command: blkid -o value -s UUID {{ root_partition }}
  register: blkid_result
  changed_when: false

- name: Update /etc/crypttab
  ansible.builtin.lineinfile:
    path: "{{ newroot_mount }}/etc/crypttab"
    line: "{{ encrypted_root_name }} UUID={{ blkid_result.stdout }} none luks,discard"
    create: yes
    mode: '0644'

- name: Update /etc/fstab
  ansible.builtin.replace:
    path: "{{ newroot_mount }}/etc/fstab"
    regexp: '^LABEL=cloudimg-rootfs\s+/\s+ext4\s+discard,commit=30,errors=remount-ro\s+0\s+1$'
    replace: '/dev/mapper/{{ encrypted_root_name }}\t/\text4\tdiscard,errors=remount-ro\t0 1'
    backup: yes

- name: Copy TDX initramfs hooks
  ansible.builtin.copy:
    src: files/initramfs/fetch_key
    dest: "{{ newroot_mount }}/etc/initramfs-tools/hooks/fetch_key"
    mode: '0755'
    owner: root
    group: root

- name: Copy TDX module loader script (init-top)
  ansible.builtin.copy:
    src: files/initramfs/load-tdx
    dest: "{{ newroot_mount }}/etc/initramfs-tools/scripts/init-top/load-tdx"
    mode: '0755'
    owner: root
    group: root

- name: Copy TDX unlock script (init-premount)
  ansible.builtin.copy:
    src: files/initramfs/fetch_key_and_unlock
    dest: "{{ newroot_mount }}/etc/initramfs-tools/scripts/init-premount/fetch_key_and_unlock"
    mode: '0755'
    owner: root
    group: root

- name: Copy containerd cache setup script (init-bottom)
  ansible.builtin.copy:
    src: files/initramfs/setup_containerd_cache
    dest: "{{ newroot_mount }}/etc/initramfs-tools/scripts/init-bottom/setup_containerd_cache"
    mode: '0755'
    owner: root
    group: root

- name: Create TDX environment configuration
  ansible.builtin.copy:
    content: |
      # TDX LUKS Configuration
      TDX_API_ENDPOINT="{{ tdx_api_endpoint }}"
      TDX_NONCE_ENDPOINT="{{ tdx_nonce_endpoint }}"
      TDX_LUKS_ENDPOINT="{{ tdx_luks_endpoint }}"
      TDX_TIMEOUT="{{ tdx_timeout }}"
      TDX_RETRY_COUNT="{{ tdx_retry_count }}"
    dest: "{{ newroot_mount }}/etc/tdx-luks.conf"
    mode: '0644'
    owner: root
    group: root

- name: Source TDX config in initramfs script
  ansible.builtin.replace:
    path: "{{ newroot_mount }}/etc/initramfs-tools/scripts/init-premount/fetch_key_and_unlock"
    regexp: '# Configuration'
    replace: |
      # Configuration
      [ -f /etc/tdx-luks.conf ] && . /etc/tdx-luks.conf

- name: Update initramfs and grub in chroot
  ansible.builtin.shell: |
    chroot {{ newroot_mount }} /bin/bash -c "
      update-initramfs -u -k all &&
      update-grub
    "
  register: chroot_update_result
  changed_when: chroot_update_result.rc == 0

- name: Unmount system directories
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/{{ item }}"
    state: unmounted
  loop:
    - sys/firmware/efi/efivars
    - proc
    - sys
    - dev
    - run
    - boot/efi
    - boot
    - ""

- name: Close LUKS container
  community.crypto.luks_device:
    name: "{{ encrypted_root_name }}"
    state: closed

- name: Disconnect nbd device
  ansible.builtin.command: qemu-nbd --disconnect {{ nbd_device }}
  args:
    removes: "{{ nbd_device }}"
  register: qemu_nbd_disconnect_result
  changed_when: qemu_nbd_disconnect_result.rc == 0

- name: Clean up temporary directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ root_mount }}"
    - "{{ newroot_mount }}"
    - "{{ backup_dir }}"

- name: Clean up temporary files
  ansible.builtin.file:
    path: "/tmp/luks_keyfile"
    state: absent