---
- name: Install dependencies
  ansible.builtin.apt:
    name:
      - git
      - libguestfs-tools
      - virtinst
      - genisoimage
      - libvirt-daemon-system
      - qemu-utils
      - cryptsetup
      - cloud-image-utils
    state: present
    update_cache: yes

- name: Detect non-conflicting network for build VM
  ansible.builtin.shell: |
    python3 << 'PYEOF'
    import ipaddress, json, subprocess
    result = subprocess.run(['ip', '-4', '-o', 'addr', 'show'], capture_output=True, text=True)
    host_supernets = set()
    for line in result.stdout.strip().split('\n'):
        if not line.strip():
            continue
        parts = line.split()
        iface = parts[1]
        if iface == 'lo' or iface.startswith('virbr'):
            continue
        for i, p in enumerate(parts):
            if p == 'inet' and i + 1 < len(parts):
                addr = ipaddress.ip_interface(parts[i + 1])
                supernet = ipaddress.ip_network(str(addr.ip) + '/16', strict=False)
                host_supernets.add(supernet)
    candidates = {{ build_vm_network_candidates | to_json }}
    selected = candidates[-1]
    for c in candidates:
        gw_supernet = ipaddress.ip_network(c['gateway'] + '/16', strict=False)
        if not any(gw_supernet.overlaps(h) for h in host_supernets):
            selected = c
            break
    print(json.dumps(selected))
    PYEOF
  register: _network_detection
  changed_when: false

- name: Set build VM network configuration
  ansible.builtin.set_fact:
    build_vm_ip: "{{ (_network_detection.stdout | from_json).vm_ip }}"
    _net_gateway: "{{ (_network_detection.stdout | from_json).gateway }}"
    _net_netmask: "{{ (_network_detection.stdout | from_json).netmask }}"
    _net_dhcp_start: "{{ (_network_detection.stdout | from_json).dhcp_start }}"
    _net_dhcp_end: "{{ (_network_detection.stdout | from_json).dhcp_end }}"

- name: Display selected build VM network
  ansible.builtin.debug:
    msg: "Selected build VM network: {{ _net_gateway }}/{{ _net_netmask }} (VM IP: {{ build_vm_ip }})"

- name: Check if build VM network exists
  ansible.builtin.shell: virsh net-info {{ build_vm_network }} 2>/dev/null
  register: _net_exists
  changed_when: false
  failed_when: false

- name: Get existing network gateway
  ansible.builtin.shell: |
    virsh net-dumpxml {{ build_vm_network }} | python3 -c "
    import sys, xml.etree.ElementTree as ET
    root = ET.parse(sys.stdin).getroot()
    print(root.find('ip').get('address', ''))
    "
  register: _existing_gateway
  when: _net_exists.rc == 0
  changed_when: false

- name: Destroy VM on stale network
  ansible.builtin.command: virsh destroy "{{ vm_name }}"
  when: _net_exists.rc == 0 and _existing_gateway.stdout != _net_gateway
  changed_when: false
  failed_when: false

- name: Undefine VM on stale network
  ansible.builtin.command: virsh undefine "{{ vm_name }}"
  when: _net_exists.rc == 0 and _existing_gateway.stdout != _net_gateway
  changed_when: false
  failed_when: false

- name: Destroy stale network
  ansible.builtin.command: virsh net-destroy {{ build_vm_network }}
  when: _net_exists.rc == 0 and _existing_gateway.stdout != _net_gateway
  changed_when: false
  failed_when: false

- name: Undefine stale network
  ansible.builtin.command: virsh net-undefine {{ build_vm_network }}
  when: _net_exists.rc == 0 and _existing_gateway.stdout != _net_gateway
  changed_when: false
  failed_when: false

- name: Define build VM network
  ansible.builtin.shell: |
    virsh net-define /dev/stdin <<'EOF'
    <network>
      <name>{{ build_vm_network }}</name>
      <forward mode="nat"/>
      <bridge name="{{ build_vm_network_bridge }}" stp="on" delay="0"/>
      <ip address="{{ _net_gateway }}" netmask="{{ _net_netmask }}">
        <dhcp>
          <range start="{{ _net_dhcp_start }}" end="{{ _net_dhcp_end }}"/>
        </dhcp>
      </ip>
    </network>
    EOF
  when: _net_exists.rc != 0 or _existing_gateway.stdout != _net_gateway

- name: Ensure build VM network is active
  ansible.builtin.command: virsh net-start {{ build_vm_network }}
  changed_when: false
  failed_when: false

- name: Set build VM network to autostart
  ansible.builtin.command: virsh net-autostart {{ build_vm_network }}
  changed_when: false
  failed_when: false

- name: Remove any existing DHCP reservations for build VM
  ansible.builtin.shell: |
    virsh net-dumpxml {{ build_vm_network }} | grep -q "{{ build_vm_mac }}" && \
    virsh net-update {{ build_vm_network }} delete ip-dhcp-host \
      "<host mac='{{ build_vm_mac }}'/>" --live --config || true
  changed_when: false
  failed_when: false

- name: Create static DHCP reservation for build VM
  ansible.builtin.command: |
    virsh net-update {{ build_vm_network }} add-last ip-dhcp-host \
      "<host mac='{{ build_vm_mac }}' name='build-node' ip='{{ build_vm_ip }}'/>" \
      --live --config
  register: reservation_result
  failed_when: false
  changed_when: "'Updated' in reservation_result.stdout or reservation_result.rc == 0"

- name: Check if base image exists
  ansible.builtin.stat:
    path: "{{ base_img_path }}"
  register: base_image
  failed_when: not base_image.stat.exists

- name: Check if build image exists
  ansible.builtin.stat:
    path: "{{ build_img_path }}"
  register: build_image

- name: Create cloud-init user-data with SSH key
  ansible.builtin.copy:
    content: |
      #cloud-config
      hostname: build-node
      timezone: UTC
      users:
        - name: root
          ssh-authorized-keys:
            - "{{ lookup('file', ssh_public_key_path | expanduser)  }}"
    dest: "{{ user_data_file }}"
    mode: '0644'

- name: Check if KVM is available
  ansible.builtin.command: kvm-ok
  register: kvm_check
  changed_when: false
  failed_when: false

- name: Set virt_type based on KVM availability
  ansible.builtin.set_fact:
    virt_type: "{{ 'kvm' if kvm_check.rc == 0 else 'qemu' }}"

- name: Check if VM exists
  ansible.builtin.shell: virsh list --all | grep -q "{{ vm_name }}"
  register: vm_exists
  changed_when: false
  failed_when: false

- name: Debug
  ansible.builtin.debug:
    msg: "{{ vm_exists }}"

- name: Destroy existing VM
  ansible.builtin.command: virsh destroy "{{ vm_name }}"
  when: vm_exists.rc == 0 and (no_cache == 'true' or vm_exists.stdout != '')
  changed_when: false
  failed_when: false

- name: Undefine existing VM
  ansible.builtin.command: virsh undefine "{{ vm_name }}"
  when: vm_exists.rc == 0 and (no_cache == 'true' or vm_exists.stdout != '')
  changed_when: false
  failed_when: false

# - name: Set qemu user and group
#   ansible.builtin.set_fact:
#     qemu_user: "{{ lookup('file', '/etc/libvirt/qemu.conf') | regex_search('(?m)^user = \"(.*)\"', '\\1') | first }}"
#     qemu_group: "{{ lookup('file', '/etc/libvirt/qemu.conf') | regex_search('(?m)^group = \"(.*)\"', '\\1') | first }}"

- name: Ensure libvirt image directory exists
  ansible.builtin.file:
    path: "{{ libvirt_image_dir }}"
    state: directory
    mode: "0755"

- name: Copy QCOW2 image into libvirt storage
  ansible.builtin.copy:
    src: "{{ base_img_path }}"
    dest: "{{  build_img_path }}"
    mode: "0644"
    remote_src: yes
  when: (not build_image.stat.exists) or (no_cache == 'true')

- name: Configure libvirt to enable dynamic ownership
  ansible.builtin.lineinfile:
    path: /etc/libvirt/qemu.conf
    regexp: '^#?dynamic_ownership\s*='
    line: 'dynamic_ownership = 1'
    backup: yes
  notify: restart libvirtd

- name: Ensure libvirt changes are applied
  ansible.builtin.meta: flush_handlers

- name: Fix permissions on libvirt cloud-init ISO directory
  ansible.builtin.file:
    path: /var/lib/libvirt/boot
    mode: "0755"

- name: Fix permissions on libvirt dir
  ansible.builtin.file:
    path: /var/lib/libvirt
    mode: "0755"

- name: Create cloud-init ISO manually
  ansible.builtin.command:
    cmd: cloud-localds /var/lib/libvirt/boot/tdx-cloudinit.iso "{{ user_data_file }}"
  args:
    creates: /var/lib/libvirt/boot/tdx-cloudinit.iso
  when: (not build_image.stat.exists) or (no_cache == 'true')

- name: Set cloud-init ISO permissions
  ansible.builtin.file:
    path: /var/lib/libvirt/boot/tdx-cloudinit.iso
    mode: "0644"

- name: Start temporary VM
  ansible.builtin.command: |
    virt-install \
      --name "{{ vm_name }}" \
      --ram 3072 \
      --vcpus 2 \
      --disk path="{{ build_img_path }}",format=qcow2 \
      --disk path=/var/lib/libvirt/boot/tdx-cloudinit.iso,device=cdrom \
      --os-variant ubuntu{{ ubuntu_version }} \
      --virt-type "{{ virt_type }}" \
      --network network={{ build_vm_network }},mac={{ build_vm_mac }} \
      --graphics vnc,listen=0.0.0.0,port="{{ vnc_port }}" \
      --import \
      --noautoconsole
  register: virt_install_result
  when: vm_exists.rc != 0 or no_cache == 'true'
  changed_when: virt_install_result.rc == 0
  failed_when: virt_install_result.rc != 0

- name: Check if VM is running
  ansible.builtin.shell: virsh list --state-running | grep -q "{{ vm_name }}"
  register: vm_running
  changed_when: false
  failed_when: false
  when: vm_exists.rc == 0 or no_cache == 'true'  # Only check if VM exists

- name: Start existing VM if not running
  ansible.builtin.command: virsh start "{{ vm_name }}"
  when: vm_exists.rc == 0 and vm_running.rc != 0 and no_cache == 'false'  # Run if VM exists but isn't running
  register: virt_start_result
  changed_when: virt_start_result.rc == 0
  failed_when: virt_start_result.rc != 0

- name: Wait for VM to be running
  ansible.builtin.shell: virsh list --state-running | grep -q "{{ vm_name }}"
  register: vm_running
  retries: 60
  delay: 10
  until: vm_running.rc == 0
  failed_when: vm_running.rc != 0
  changed_when: false

- name: Wait for SSH to be available on static IP
  ansible.builtin.wait_for:
    host: "{{ build_vm_ip }}"
    port: 22
    state: started
    timeout: 600
  delegate_to: localhost

- name: Update VM host with static IP
  ansible.builtin.add_host:
    name: build-node
    ansible_host: "{{ build_vm_ip }}"
    ansible_user: root
    ansible_ssh_private_key_file: "{{ ssh_private_key_path | expanduser }}"
    groups: vm